package TinkoffExam;
//Пошел как-то лесник в лес по грибы, да не в абы какой лес! В клетке либо трава зеленая,
//либо грибочки белые, либо кусты кусачие. Кусачие кусты, разумеется, непроходимые.
//Трава зеленая скучная, а грибочки белые, разумеется, по-настоящему интересные.
//
//Лес можно представить в виде клетчатой таблицы размера n×3.
//Свою дорогу лесник начинает в любой из трех клеток первой строки.
//После чего каждый раз он может переместиться на следующую строку в соседнюю по углу или стороне клетку,
//если такая существуют и там не кусты кусачие. Более формально, находясь в клетке (i,j) он может переместиться
//в одну из трех доступных для прохода клеток (i+1,j−1), (i+1,j) и (i+1,j+1), если они существуют и там нет кустов.
//
//Леснику, конечно же, интересны грибочки белые, поэтому он хочет знать, какое максимальное их количество
//он может посетить за прогулку. Если лесник упирается в клетку, из которой никуда не может пойти, он заканчивает свою прогулку.
//
//Формат входных данных
//В первой строке задано число n — количество строк в лесу (1≤n≤10^4). В следующих n строках дано по три символа,
//характеризующих данную строку. Каждый символ равен «.», если в клетке только трава зеленая, «C»,
//если в этой клетке растут грибочки белые, и «W», если кусты кусачие.
//Если в первой строке во всех клетках находятся кусты, прогулка лесника заканчивается, не успев начаться.
//
//Формат выходных данных
//Выведите одно число — наибольшее количество грибов, которые лесник сможет собрать за одну такую прогулку.
//Примеры данных
//Пример 1
//5
//W.W
//C.C
//WW.
//CC.
//CWW
//
//3
//Пример 2
//4
//W.W
//CWC
//W.W
//CWW
//
//2
//Пример 3
//4
//W.W
//..C
//WW.
//C..
//
//1
import java.util.Scanner;

public class Main5 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        char[][] forest = new char[n][3];

        for (int i = 0; i < n; i++) {
            String line = scanner.next();
            for (int j = 0; j < 3; j++) {
                forest[i][j] = line.charAt(j);
            }
        }
        System.out.println(countMushrooms(forest, n));
    }

    public static int countMushrooms(char[][] forest, int n) {
        int[][] dp = new int[n][3];
        for (int i = 0; i < 3; i++) {
            if (dp[0][i] != 'W') {
                dp[0][i] = (forest[0][i] == 'C') ? 1 : 0;
            }
        }

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < 3; j++) {
                if (forest[i][j] != 'W') {
                    dp[i][j] = Math.max(dp[i - 1][j], Math.max(
                                    (j - 1 >= 0 && forest[i - 1][j - 1] != 'W') ? dp[i - 1][j - 1] : 0,
                                    (j + 1 < 3 && forest[i - 1][j + 1] != 'W') ? dp[i - 1][j + 1] : 0
                            )
                    ) + (forest[i][j] == 'C' ? 1 : 0);
                }
            }
        }
        return Math.max(Math.max(dp[n - 1][0], dp[n - 1][1]), dp[n - 1][2]);
    }
}
