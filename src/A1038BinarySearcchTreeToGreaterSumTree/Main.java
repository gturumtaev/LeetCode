package A1038BinarySearcchTreeToGreaterSumTree;
//Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST
// is changed to the original key plus the sum of all keys greater than the original key in BST.
//As a reminder, a binary search tree is a tree that satisfies these constraints:
//The left subtree of a node contains only nodes with keys less than the node's key.
//The right subtree of a node contains only nodes with keys greater than the node's key.
//Both the left and right subtrees must also be binary search trees.
//Учитывая корень двоичного дерева поиска (BST), преобразуйте его в большее дерево так, чтобы каждый ключ исходного BST
// заменяется исходным ключом плюс сумма всех ключей, превышающих исходный ключ в BST.
//Напоминаем, что двоичное дерево поиска — это дерево, удовлетворяющее следующим ограничениям:
//Левое поддерево узла содержит только узлы с ключами меньше ключа узла.
//Правое поддерево узла содержит только узлы с ключами, превышающими ключ узла.
//И левое, и правое поддеревья также должны быть бинарными деревьями поиска.Учитывая корень двоичного дерева поиска (BST), преобразуйте его в большее дерево так, чтобы каждый ключ исходного BST
//// заменяется исходным ключом плюс сумма всех ключей, превышающих исходный ключ в BST.
////Напоминаем, что двоичное дерево поиска — это дерево, удовлетворяющее следующим ограничениям:
////Левое поддерево узла содержит только узлы с ключами меньше ключа узла.
////Правое поддерево узла содержит только узлы с ключами, превышающими ключ узла.
////И левое, и правое поддеревья также должны быть бинарными деревьями поиска.
//
//
//Example 1:
//
//
//Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
//Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
//Example 2:
//
//Input: root = [0,null,1]
//Output: [1,null,1]

public class Main {
    public static void main(String[] args) {

    }

    public TreeNode bstToGst(TreeNode root) {
        return null;
    }
}
